{"pages":[{"title":"关于","text":"关于我我是一个普普通通大二学生，现在寻求方向。","link":"/about/index.html"}],"posts":[{"title":"通过右移2的幂次实现被除数为负数的除法","text":"在阅读CSAPP的时候，看了练习题3.20的答案，说到被除数为负数的时候需要加偏置。 WHY?总结了一下CSAPP中的解释（书P73）计算机实现除法的时候，需要的时钟周期很长，所以当除数为2的幂次的时候，就可以使用算术右移来实现除法。 被除数非负的情况整数的除法总是舍入到零的，比如2.3舍入到2， -1.5舍入到-1。当被除数为正数的时候，算术右移来执行除法，结果自然是向零舍入的。（因为直接把后面右移的数字舍弃了） 被除数负数的情况但是当被除数是负数的时候，会出现向下舍入，比如-1.5会被舍入为-2。为了解决这个问题，我们需要先对被除数加上一个偏置数。当除数为2的k次幂的时候，偏置量为2^k - 1这样就可以解决被除数为负数的舍入问题。以下为CSAPP中的推导 个人简单理解假设除数为2的k次幂，代表我们要右移k位，当这k位都为0的时候，代表不需要舍入，能够整除，但是当k位有任何一位为1的时候，代表不能整除，需要做舍入处理。如果不加偏置，就代表我们要直接舍弃最低的k位，对不需要右移的最低位毫无影响，那么对于负数来说。如果加上偏置，那么需要舍入的时候，对于第k+1位，会有一个来自低位的进位，这个时候数值自然就会向0舍入。","link":"/2021/07/19/%E9%80%9A%E8%BF%87%E5%8F%B3%E7%A7%BB2%E7%9A%84%E5%B9%82%E6%AC%A1%E5%AE%9E%E7%8E%B0%E9%99%A4%E6%B3%95/"},{"title":"《STL源码剖析》第二章问题杂烩","text":"近期开始阅读侯捷《STL源码剖析》，第二章有许许多多我遇到的问题，在此汇总一下 Placement new书中的使用 语法new的语法中有placement_params可选参数，当传递给new这个参数时，就是placement_new 作用placement_new就是直接将一块内存空间指定给new，new直接在这些内存上执行构造 样例1234567891011121314//样例1void* operator new(std::size_t, void*)//样例2// within any block scope...{ alignas(T) unsigned char buf[sizeof(T)]; // Statically allocate the storage with automatic storage duration // which is large enough for any object of type `T`. T* tptr = new(buf) T; // Construct a `T` object, placing it directly into your // pre-allocated storage at memory address `buf`. tptr-&gt;~T(); // You must **manually** call the object's destructor // if its side effects is depended by the program.} // Leaving this block scope automatically deallocates `buf`. false_type和true_type书中的使用书中是用来方便__destory_aux的调用，个人理解为重载，可以由__destroy直接调用两个不同作用的函数，通过false_type和true_type这两个不同的变量类型。 未完待续….","link":"/2021/08/18/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%97%AE%E9%A2%98%E6%9D%82%E7%83%A9/"},{"title":"《STL源码剖析》中void (* set_malloc_handler(void (*f)()))()分析","text":"问题在阅读《STL源码剖析》的时候，遇到了这么一个函数 先不说函数的意思，函数的形式我就没看懂…好多好多括号… 函数指针函数指针就是指向函数的指针… 1234567891011121314151617181920212223242526272829/* 例一：函式指標直接呼叫 复制自WIKI*/# ifndef __cplusplus # include &lt;stdio.h&gt;# else # include &lt;cstdio&gt;# endifint max(int x, int y){ return x &gt; y ? x : y;}int main(void){ /* p 是函数指针*/ int (* p)(int, int) = &amp; max; // &amp;可以省略 int a, b, c, d; printf(&quot;please input 3 numbers:&quot;); scanf(&quot;%d %d %d&quot;, &amp; a, &amp; b, &amp; c); /* 與直接呼叫函式等價，d = max(max(a, b), c) */ d = p(p(a, b), c); printf(&quot;the maxumum number is: %d\\n&quot;, d); return 0;} 在《STL源码剖析》里的这个函数，实际上使用了函数指针作为参数 1void (*f)() 函数指针作为返回值1int (*test(int))(int, int) 阅读方法是由内向外读，首先test有形参列表，所以是一个函数，并且参数只需要一个int，然后test的前面有一个*，所以返回一个指针，(*test(int))作为一个指针，有形参列表(int, int)，所以这个指针指向函数，并且这个函数返回int类型的值。 分析1void (* set_malloc_handler(void (*f)()))() 首先，set_malloc_handler作为函数名，有一个形参，是void(*f)()，void(f)()是一个函数指针类型，指向返回值为void，参数为空的函数。这说明set_malloc_handler是函数，并且前面有，所以要返回指针，指针后面接着形参列表，为空()，说明是指向函数的指针，并且指向的函数返回类型为void。","link":"/2021/08/20/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"},{"title":"动态图综述笔记","text":"本文是动态网络综述：Foundations and modelling of dynamicnetworks using Dynamic Graph NeuralNetworks: A survey 的笔记 分类根据时间粒度分类 Static没有时间信息 Edge-weighted时间信息被当做标签存放在静态网络的边/点中，最直观的例子是静态网络中边最后一次活跃时间的标签。 Discretue以离散的时间间隔表示时间信息，可以用不同时间间隔的快照来表示。 Continuous没有时间间隔，这种表示方式承载着最多的信息，但同时也最复杂。 后两者主要用来建立动态网络。 表示方法 Discrete RepresentationT代表快照的序号 Continuous Representation The event-basedrepresentationui和vi是一对连接的点，ti是时间戳，代表连接开始的时间，△i是事件(连接)持续的时间 The contact sequence representation是上一种的简化，在这种连接中，连接是instantaneous(瞬时)的，所以没有连接的持续时间。 The graph stream representation其中 ui,vi是一对连接的点，ti是事件发生的时间，最后的符号如果为1，代表边的的加入，-1代表边的删除。 根据连接时间分类 Interaction Temporal Evolving Strictly evolving 从上到下连接时间为0-无穷 根据点的动态性区分 Static点的数量始终不变 Dynamic点可能消失或出现 Growin是一种特殊的Dynamic，点只能增长 动态网络CUBEtemporal可以在没有连接的情况下存在，但对于evolving等许多网络来说不可以，当连接不存在时，点也就不存在了。","link":"/2021/09/13/%E5%8A%A8%E6%80%81%E5%9B%BE%E7%BB%BC%E8%BF%B0%E7%AC%94%E8%AE%B0/"}],"tags":[],"categories":[]}